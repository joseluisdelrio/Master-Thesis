---
title: "A Pectin-Based Prebiotic Fiber Modulates Liver Transcriptome Dysregulation in Diet-Induced Obese Mice"
author: "Del Rio-Vazquez, Jose Luis; Barrera-Chamorro, Luna; Marquez-Paradas, Elvira; Montserrat-de la Paz, Sergio and Claro-Cala, Carmen*."
output: html_document
---

# 1. Data loading.

Firstly, all needed packages will be loaded.

```{r include=FALSE}
lapply(c("dplyr", "kableExtra", "FactoMineR", "factoextra", "NormalyzerDE", 
         "Biobase", "MuSiC", "SingleCellExperiment", "ggplot2", "reshape2", 
         "DESeq2", "ggVennDiagram", "clusterProfiler", "org.Mm.eg.db", 
         "forcats", "stringr", "readr", "mixOmics", "tibble", "pathview",
         "ComplexHeatmap", "circlize", "grid"), library, 
       character.only = TRUE)
```

For file reading purposes, I have developed a customized function which reads the .tsv transcription files from StringTie and creates the expression matrix.

```{r}
expression_matrix <- function (directory, names){ # 2 paramethers are given
  # Read .tsv files and save it into a list
  archives <- list.files (directory, pattern = "*.tsv", full.names = TRUE)
  # Save the first element, which is a .tsv file
  data1 <- read.table (archives [1], header = TRUE, sep = "\t")
  # Save the gene IDs into a new variable 
  gene.ids <<- data1$Gene.ID
  # Create an expression matrix with the current file's data.
  gene.expression <- matrix (data1$TPM, nrow = length (gene.ids))
  # The same process is repeated in the following files
  for (i in 2:length(archives)){
    data <- read.table (archives[i], header = TRUE, sep = "\t")
    expression <- data$TPM
    names (expression) <- data$Gene.ID
    # These different expression matrices are binded into a new expression matrix 
    # which contains the whole expression information
    gene.expression <- cbind (gene.expression, expression[gene.ids])
    # Verify that the .tsv files correspond to the correct matrix and sample
    print (paste (archives [i], names [i]))
  }
  colnames (gene.expression) <- names
  return (gene.expression)
}
```

Samples' names must be defined.

```{r}
samples <- c("control1", "control2", "control3",
             "hfd1", "hfd2", "hfd3",
             "hfdpp1", "hfdpp2", "hfdpp3")
```

Next, files are read from tsv.data folder with the new function and need to be given the samples' names.

```{r message=FALSE, include=FALSE}
gene.expression <- expression_matrix ("./tsv_data2", samples)
```

It's time to take a look to our expression matrix.

```{r}
head(as.data.frame(gene.expression)) %>%
  kbl(caption = "Gene Expression Matrix") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = FALSE)  %>%
  kableExtra::kable_styling(latex_options = "H")
```

Now, 1 is added to gene expression matrix to avoid zero logarithms when log2-transformed.

```{r}
gene.expression.1 <- gene.expression + 1
write.table (gene.expression.1, file = "obesity_expression_1.tsv",
             quote = FALSE, row.names = F, sep = "\t")
par(mfrow=c(1, 2))
boxplot(gene.expression,outline=F,las=2,main="Gene Expression (TPM)",
        col=rep(c("lightyellow","lightgreen", "lightblue"),each=3))
# Log2 is applied.
boxplot(log2(gene.expression.1),outline=F,las=2,main="Gene Expression log2(TPM + 1)",
        col=rep(c("lightyellow","lightgreen", "lightblue"),each=3))

```

# 2. Data preprocessing.

We perform Principal Component Analysis (PCA) before and after data normalization.

```{r}
pca.gene.raw <- data.frame(colnames(gene.expression.1), t(gene.expression.1))
colnames(pca.gene.raw)[1] <- "Samples"
```

PCA before data normalization.

```{r}
res.pca.raw <- PCA(pca.gene.raw,
                   graph = FALSE,
                   scale.unit = TRUE,
                   quali.sup = 1)
design <- data.frame (sample = colnames (gene.expression.1), 
                      group = c("Control", "Control", "Control",
                                "HFD", "HFD", "HFD",
                                "HFDpp", "HFDpp", "HFDpp"))
p2.3 <- fviz_pca_ind(
  res.pca.raw,
  col.ind = design$group,
  pointsize = 2,
  pointshape = 21,
  fill = "black",
  repel = TRUE,
  addEllipses = TRUE,
  ellipse.type = "confidence",
  legend.title = "Conditions",
  title = "PCA of samples (Unnormalized)",
  axes = c(2, 3),
  show_legend = TRUE,
  show_guide = TRUE
)
print(p2.3)
ggsave("PCA_plot_unnormalized.svg", plot = p2.3, width = 8, height = 6, dpi = 300)
```

Data is quite well classified in the second and third component, but normalization is needed in order to improve the analysis' quality.

```{r}
# design is needed, but previously defined.
write.table (design, "design_obesity.tsv", sep = "\t", row.names = F,
             quote = F)
normalyzer (jobName = "obesity_norm", outputDir = ".",
            designPath = "design_obesity.tsv", 
            dataPath = "obesity_expression_1.tsv")
```

Quantile normalization is chosen and charged into a new variable.

```{r}
normalized.gene <- read.table (file = "obesity_normal_norm2/Quantile-normalized.txt", 
                               header = T)
boxplot(normalized.gene, 
        outline = FALSE,                
        las = 2,                        
        col = rep(c("lightyellow","lightgreen", "lightblue"), each = 3), 
        main = "Gene Expression After Quantile Normalization (TPM)", 
        ylab = "Normalized Expression (TPM)")
```

Now, it might be helpful to create a function to build scatter plots for pairwise comparisons of replicates.

```{r}
scatter_plot_replicates <- function(data, group, replicates) {
  # Generate all possible combinations
  combinations <- combn(paste0(group, 1:replicates), 2, simplify = FALSE)
  # Iterate through each pair to create scatter plots
  for (i in combinations) {
    # Generate scatter plot for the selected pair of replicates
    plot(x = data[, i[[1]]], y = data[, i[[2]]], pch = 19, col = "darkgrey",
         xlab = i[[1]], ylab = i[[2]], cex = 0.5)
    # Calculate the correlation coefficient between the replicates
    text(x = 4, y = 12,
         labels = paste(c(
           "cor = ",  
           round(100 * cor(data[, i[[1]]], data[, i[[2]]], use = "complete.obs"),
                 digits = 3),  
           "%"), collapse = ""))
  }
}
```

Checking the scatter plots is recommended in order to verify that there is a high similarity between samples of the same condition.

```{r}
svg("replicate_control_scatterplots.svg", width = 12, height = 4)
par(mfrow = c(1, 3))
scatter_plot_replicates(normalized.gene, "control", 3)
dev.off()
par(mfrow = c(1, 3))
scatter_plot_replicates(normalized.gene, "control", 3)
```

```{r}
svg("replicate_hfd_scatterplots.svg", width = 12, height = 4)
par(mfrow = c(1, 3))
scatter_plot_replicates(normalized.gene, "hfd", 3)
dev.off()
par(mfrow = c(1, 3))
scatter_plot_replicates(normalized.gene, "hfd", 3)
```

```{r}
svg("replicate_hfdpp_scatterplots.svg", width = 12, height = 4)
par(mfrow = c(1, 3))
scatter_plot_replicates(normalized.gene, "hfdpp", 3)
dev.off()
par(mfrow = c(1, 3))
scatter_plot_replicates(normalized.gene, "hfdpp", 3)
```

Now, a new PCA is performed to check if there has been any improvement compared to the unnormalized data.

```{r}
pca.gene <- data.frame(colnames(normalized.gene), t(normalized.gene))
colnames(pca.gene)[1] <- "Samples"
res.pca.normalized <- PCA(pca.gene, 
               graph = FALSE,
               scale.unit = TRUE,
               quali.sup = 1 )
p1.3.normal <- fviz_pca_ind(res.pca.normalized, col.ind = design$group, 
             pointsize=2, pointshape=21,fill="black",
             repel = TRUE, 
             addEllipses = TRUE,ellipse.type = "confidence",
             legend.title="Conditions",
             title="PCA of samples normalyzed",
             axes = c(1, 3),
             show_legend=TRUE,show_guide=TRUE)
print(p1.3.normal)
ggsave("PCA_plot_normalized.svg", plot = p1.3.normal, width = 8, 
       height = 6, dpi = 300)
```

# 3. Checking cell types.

We are performing a transcriptomic analysis from whole liver samples from *Mus musculus*. Large organs are usually formed by a great variety of types of cells, however, the liver is characterized by a more homogeneous composition, with almost a hundred percent of hepatocytes. Here, we used the package MuSiC to estimate the proportions of cell types contributing to our bulk RNA-seq signal by deconvolving it using a publicly available single-cell RNA-seq reference dataset. Single cell data GSE: 166504. PMID: 34755088.

The dataset has some samples that will not be used in our analysis, and they were not used before neither, so it must be taken into account and delete them from the gene count matrix. Also, the next chunk is designed not to be run, because it takes several hours. The output is shown below.

```{r eval=FALSE, include=TRUE}
# Load previously saved variables: sc_counts and sc_meta.
load("files_sc_music.RData")
# Read bulk RNA-seq gene count matrix
gene.count.matrix <- read.table(file = "gene_matrix/gene_count_matrix.csv",
                                header = TRUE, sep = ",", row.names = 1)
# Remove sample versions that won't be used
gene.count.matrix <- gene.count.matrix[, !(colnames(gene.count.matrix) %in% 
                                             c("control3", "hfd3", "hfdpp3"))]
colnames(gene.count.matrix)[colnames(gene.count.matrix) == "control4"] <- "control3"
colnames(gene.count.matrix)[colnames(gene.count.matrix) == "hfd4"] <- "hfd3"
colnames(gene.count.matrix)[colnames(gene.count.matrix) == "hfdpp4"] <- "hfdpp3"
# Select cleaned samples for bulk deconvolution
bulk_counts <- gene.count.matrix
# Create metadata (phenotype data) for bulk samples
sample_info <- data.frame(
  condition = rep(c("control", "hfd", "hfdpp"), each = 3),
  row.names = colnames(bulk_counts)
)
# Create ExpressionSet object for bulk data
bulk.eset <- ExpressionSet(
  assayData = as.matrix(bulk_counts),
  phenoData = AnnotatedDataFrame(sample_info)
)

# Optional: commands to load single-cell data if not loaded already. It takes some time.
# sc_counts <- read.delim("data_single_cell/GSE166504_cell_raw_counts.20220204.txt.gz", row.names = 1)
# sc_meta <- read.delim("data_single_cell/GSE166504_cell_metadata.20220204.tsv.gz")

# Preview single-cell metadata and expression matrix
head(sc_meta)
head(sc_counts)
# Extract the CellID from column names in sc_counts if they contain a prefix
colnames(sc_counts) <- sub(".*_", "", colnames(sc_counts))
# Identify common cells present in both count matrix and metadata
common_ids <- intersect(colnames(sc_counts), sc_meta$CellID)
# Subset expression matrix and metadata to common cells
sc_counts_clean <- sc_counts[, common_ids]
sc_meta_clean <- sc_meta[sc_meta$CellID %in% common_ids, ]
# Remove duplicated entries in metadata
sc_meta_clean <- sc_meta_clean[!duplicated(sc_meta_clean$CellID), ]
# Set rownames of metadata to CellID to match expression matrix
rownames(sc_meta_clean) <- sc_meta_clean$CellID
# Create SingleCellExperiment object from cleaned single-cell data
sc.sce <- SingleCellExperiment(
  assays = list(counts = as.matrix(sc_counts_clean)),
  colData = sc_meta_clean
)

# Clean gene names to enable alignment

# Remove Ensembl IDs or prefixes before "|" and convert to uppercase (bulk)
bulk_rownames <- toupper(sub(".*\\|", "", rownames(bulk_counts)))
# Convert single-cell gene names to uppercase
sc_rownames <- toupper(rownames(sc_counts_clean))
# Check how many duplicates exist after transformation
sum(duplicated(bulk_rownames))  
sum(duplicated(sc_rownames))
# Remove duplicated gene names (keep only first occurrence)
bulk_counts <- bulk_counts[!duplicated(bulk_rownames), ]
rownames(bulk_counts) <- bulk_rownames[!duplicated(bulk_rownames)]
sc_counts_clean <- sc_counts_clean[!duplicated(sc_rownames), ]
rownames(sc_counts_clean) <- sc_rownames[!duplicated(sc_rownames)]
# Final normalization step to ensure all rownames are uppercase and stripped
rownames(bulk_counts) <- toupper(sub(".*\\|", "", rownames(bulk_counts)))
rownames(sc_counts_clean) <- toupper(rownames(sc_counts_clean))
# Identify genes present in both datasets
common_genes <- intersect(rownames(bulk_counts), rownames(sc_counts_clean))
# Filter both datasets by common genes
bulk.mtx.filtered <- bulk_counts[common_genes, ]
sc_counts_clean <- sc_counts_clean[common_genes, ]
# Create a filtered SingleCellExperiment object
sc.sce.filtered <- SingleCellExperiment(
  assays = list(counts = as.matrix(sc_counts_clean)),
  colData = sc_meta_clean
)

# Run MuSiC deconvolution
res_music <- music_prop(
  bulk.mtx = as.matrix(bulk.mtx.filtered),
  sc.sce = sc.sce.filtered,
  clusters = "CellType",     
  samples = "FileName"      
)

# Plot deconvolution results
# Convert to data frame for plotting
res_df <- as.data.frame(t(res_music$Est.prop.weighted))
# Add cell type as a column for plotting
res_df$CellType <- rownames(res_df)
# Convert data to long format for ggplot
df_melt <- melt(res_df, id.vars = "CellType", variable.name = "Sample", value.name = "Proportion")

# Plot barplot
plot.music <- ggplot(df_melt, aes(x = Sample, y = Proportion, fill = CellType)) +
  geom_bar(stat = "identity") +
  labs(
    title = "Cellular proportions estimated by MuSiC",
    x = "Bulk samples", y = "Cellular proportions"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave("proportions_music.svg", width = 10, height = 6, dpi = 300)
```

```{r}
print(plot.music)
```

# 4. Differential expression analysis.

First, we take the gene count matrix from StringTie output to perform this analysis with the DESeq2 package.

```{r}
# Prepare data for DESeq2
deseq.gene.ids <- gene.count.matrix$gene_id
gene.count.matrix <- gene.count.matrix[,-1]  # Remove first column
rownames(gene.count.matrix) <- deseq.gene.ids # Give gene names to rows
colnames(gene.count.matrix) <- colnames(normalized.gene) # Give groups names to columns
```

We can take a look to the gene count matrix. This matrix has discrete data as DESeq2 will apply its own normalization later.

```{r}
head(as.data.frame(gene.count.matrix)) %>%
  kbl(caption = "Head of Gene Count Matrix") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = FALSE)  %>%
  kableExtra::kable_styling(latex_options = "H")
```

We perform differential expression analysis and make contrasts.

```{r}
dds <- DESeqDataSetFromMatrix(countData=gene.count.matrix
                              [complete.cases(gene.count.matrix), ], 
                              colData=design, design = ~ group)
dds <- DESeq(dds) 
res.hfdpp.hfd <- results(dds, contrast = c("group", "HFDpp", "HFD"))
res.hfd.control <- results(dds, contrast = c("group", "HFD", "Control"))
res.hfdpp.control <- results(dds, contrast = c("group", "HFDpp", "Control"))
# summary(res.hfd.control)  
# summary(res.hfdpp.hfd)      
# summary(res.hfdpp.control)  
```

## First contrast: HFD vs Control

### UP HFD vs Control

Upregulated genes in this contrast.

```{r}
# Extract log2 fold-change values from DESeq2 results
log.fold.change.hfd.control <- res.hfd.control$log2FoldChange
# Extract adjusted p-values (FDR) from DESeq2 results
adjusted.pval.hfd.control <- res.hfd.control$padj
# Retrieve gene names from DESeq2 results
names.res.deseq.hfd.control <- rownames(res.hfd.control)
# Assign gene names as identifiers for log2 fold-change and p-values
names(log.fold.change.hfd.control) <- names.res.deseq.hfd.control
names(adjusted.pval.hfd.control) <- names.res.deseq.hfd.control
# Select upregulated genes based on thresholds: LFC > 2 and adjusted p-value < 0.05
activated.genes.hfd.control <- names.res.deseq.hfd.control[log.fold.change.hfd.control > 2 & adjusted.pval.hfd.control < 0.05]
# Remove any NA values from the list of upregulated genes
activated.genes.hfd.control <- activated.genes.hfd.control[!is.na(activated.genes.hfd.control)]
# Number of upregulated genes that meet the criteria
number.genes.upregulated.hfd.control <- length(activated.genes.hfd.control)
# Print result
cat(
  "There are", 
  number.genes.upregulated.hfd.control, 
  "genes identified as upregulated in HFD vs Control contrast\n"
)
```

### DOWN HFD vs Control

Downregulated genes in this contrast

```{r}
# Select downregulated genes based on thresholds: LFC < -2 and adjusted p-value < 0.05
downregulated.genes.hfd.control <- names.res.deseq.hfd.control[log.fold.change.hfd.control < -2 & adjusted.pval.hfd.control < 0.05]
# Remove any NA values from the list of downregulated genes
downregulated.genes.hfd.control <- downregulated.genes.hfd.control[!is.na(downregulated.genes.hfd.control)]
# Number of downregulated genes that meet the criteria
number.genes.downregulated.hfd.control <- length(downregulated.genes.hfd.control)
# Print result
cat(
  "There are", 
  number.genes.downregulated.hfd.control, 
  "genes identified as downregulated in HFD vs Control contrast\n"
)
```

Now we generate a Volcano Plot. Top 10 genes are highlighted based on the highest -log10(p-value), which indicates stronger statistical significance.

```{r}
# Build the data.frame with gene names as rownames
df <- data.frame(
  logFC    = log.fold.change.hfd.control,
  negLogP  = -log10(adjusted.pval.hfd.control),
  status   = "NS",
  row.names = names.res.deseq.hfd.control
)
# Label regulated genes
df$status[rownames(df) %in% activated.genes.hfd.control]     <- "Upregulated"
df$status[rownames(df) %in% downregulated.genes.hfd.control] <- "Downregulated"
df$status <- factor(df$status, levels = c("Downregulated", "NS", "Upregulated"))
df$gene   <- sub(".*\\|", "", rownames(df))
# Select top genes to label 
n_genes  <- 10
top_up   <- df %>% dplyr::filter(status == "Upregulated")   %>% slice_max(negLogP, n = n_genes)
top_down <- df %>% dplyr::filter(status == "Downregulated") %>% slice_max(negLogP, n = n_genes)
# Dynamic offsets
x_min    <- min(df$logFC, na.rm = TRUE)
x_max    <- max(df$logFC, na.rm = TRUE)
x_range  <- x_max - x_min
offset_x <- x_range * 0.15
y_max    <- max(df$negLogP, na.rm = TRUE)
y_min    <- min(df$negLogP, na.rm = TRUE)
y_range  <- y_max - y_min
offset_y <- y_range / (max(nrow(top_up), nrow(top_down)) + 1)
# Build labelling data.frames
f <- 0.6
label_df_up <- top_up %>%
  arrange(desc(negLogP)) %>%
  mutate(
    label_x = logFC + (x_max - logFC) * f,   
    label_y = y_max - (row_number() - 1) * offset_y,
    group   = "up"
  )
label_df_down <- top_down %>%
  arrange(desc(negLogP)) %>%
  mutate(
    label_x = logFC + (x_min - logFC) * f,   
    label_y = y_max - (row_number() - 1) * offset_y,
    group   = "down"
  )
label_df <- bind_rows(label_df_down, label_df_up)
# Colour palette
pal <- c(Downregulated = "#56B4E9", NS = "grey80", Upregulated = "#D55E00")
# Plot
ggplot(df, aes(logFC, negLogP)) +
  geom_point(aes(color = status), size = 1.5, alpha = 0.8) +
  geom_segment(data = label_df,
               aes(x = logFC, y = negLogP, xend = label_x, yend = label_y),
               color = "grey50") +
  geom_text(data = label_df,
            aes(x = label_x, y = label_y, label = gene,
                color = ifelse(group == "up", "Upregulated", "Downregulated")),
            hjust = ifelse(label_df$group == "up", 0, 1),
            size = 4, show.legend = FALSE) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "grey60") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "grey60") +
  annotate("text", x = x_min - offset_x * 1.1, y = y_max + offset_y,
           label = paste0("DOWN: ", number.genes.downregulated.hfd.control), color = pal["Downregulated"],
           hjust = 0, size = 5, fontface = "bold") +
  annotate("text", x = x_max + offset_x * 1.1, y = y_max + offset_y,
           label = paste0("UP: ", number.genes.upregulated.hfd.control), color = pal["Upregulated"],
           hjust = 1, size = 5, fontface = "bold") +
  coord_cartesian(
    xlim = c(x_min - offset_x * 1.3, x_max + offset_x * 1.3),
    ylim = c(0, y_max + offset_y * 2),
    clip = "off"
  ) +
  labs(x = "log2FoldChange (HFD / Control)",
       y = "-log10(padj)") +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "none",
    axis.text = element_text(color = "black"),
    axis.title = element_text(color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  scale_color_manual(values = pal)

ggsave("volcano_plot_hfd_control_2.svg", width = 8, height = 8, dpi = 300)

```

## Second contrast: HFDpp vs HFD

### UP HFDpp vs HFD

```{r}
log.fold.change.hfdpp.hfd <- res.hfdpp.hfd$log2FoldChange
adjusted.pval.hfdpp.hfd   <- res.hfdpp.hfd$padj
names.res.deseq.hfdpp.hfd <- rownames(res.hfdpp.hfd)
names(log.fold.change.hfdpp.hfd) <- names.res.deseq.hfdpp.hfd
names(adjusted.pval.hfdpp.hfd)   <- names.res.deseq.hfdpp.hfd
activated.genes.hfdpp.hfd <- names.res.deseq.hfdpp.hfd[
  log.fold.change.hfdpp.hfd > 2 & adjusted.pval.hfdpp.hfd < 0.05
]
activated.genes.hfdpp.hfd <- activated.genes.hfdpp.hfd[!is.na(activated.genes.hfdpp.hfd)]
number.genes.upregulated.hfdpp.hfd <- length(activated.genes.hfdpp.hfd)
total_genes_tested_hfd_control <- sum(!is.na(res.hfd.control$padj))
cat("Total genes tested:", total_genes_tested_hfd_control, "\n")
cat(
  "There are", 
  number.genes.upregulated.hfdpp.hfd, 
  "genes identified as upregulated in HFDpp vs HFD\n"
)
```

### DOWN HFDpp vs HFD

```{r}
downregulated.genes.hfdpp.hfd <- names.res.deseq.hfdpp.hfd[
  log.fold.change.hfdpp.hfd < -2 & adjusted.pval.hfdpp.hfd < 0.05
]
downregulated.genes.hfdpp.hfd <- downregulated.genes.hfdpp.hfd[!is.na(downregulated.genes.hfdpp.hfd)]
number.genes.downregulated.hfdpp.hfd <- length(downregulated.genes.hfdpp.hfd)
cat(
  "There are", 
  number.genes.downregulated.hfdpp.hfd, 
  "genes identified as downregulated in HFDpp vs HFD\n"
)
```

```{r}
df <- data.frame(
  logFC     = log.fold.change.hfdpp.hfd,
  negLogP   = -log10(adjusted.pval.hfdpp.hfd),
  status    = "NS",
  row.names = names.res.deseq.hfdpp.hfd
)
df$status[rownames(df) %in% activated.genes.hfdpp.hfd]     <- "Upregulated"
df$status[rownames(df) %in% downregulated.genes.hfdpp.hfd] <- "Downregulated"
df$status <- factor(df$status, levels = c("Downregulated", "NS", "Upregulated"))
df$gene   <- sub(".*\\|", "", rownames(df))
n_genes  <- 10
top_up   <- df %>% filter(status == "Upregulated")   %>% slice_max(negLogP, n = n_genes)
top_down <- df %>% filter(status == "Downregulated") %>% slice_max(negLogP, n = n_genes)
x_min    <- min(df$logFC, na.rm = TRUE)
x_max    <- max(df$logFC, na.rm = TRUE)
x_range  <- x_max - x_min
offset_x <- x_range * 0.15
y_max    <- max(df$negLogP, na.rm = TRUE)
y_min    <- min(df$negLogP, na.rm = TRUE)
y_range  <- y_max - y_min
offset_y <- y_range / (max(nrow(top_up), nrow(top_down)) + 1)
f <- 0.6
label_df_up <- top_up %>%
  arrange(desc(negLogP)) %>%
  mutate(
    label_x = logFC + (x_max - logFC) * f,  
    label_y = y_max - (row_number() - 1) * offset_y,
    group   = "up"
  )
label_df_down <- top_down %>%
  arrange(desc(negLogP)) %>%
  mutate(
    label_x = logFC + (x_min - logFC) * f,  
    label_y = y_max - (row_number() - 1) * offset_y,
    group   = "down"
  )
label_df <- bind_rows(label_df_down, label_df_up)
pal <- c(Downregulated = "#56B4E9", NS = "grey80", Upregulated = "#D55E00")

ggplot(df, aes(logFC, negLogP)) +
  geom_point(aes(color = status), size = 1.5, alpha = 0.8) +
  geom_segment(data = label_df,
               aes(x = logFC, y = negLogP, xend = label_x, yend = label_y),
               color = "grey50") +
  geom_text(data = label_df,
            aes(x = label_x, y = label_y, label = gene,
                color = ifelse(group == "up", "Upregulated", "Downregulated")),
            hjust = ifelse(label_df$group == "up", 0, 1),
            size = 4, show.legend = FALSE) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "grey60") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "grey60") +
  annotate("text", x = x_min - offset_x * 1.1, y = y_max + offset_y,
           label = paste0("DOWN: ", number.genes.downregulated.hfdpp.hfd),
           color = pal["Downregulated"], hjust = 0, size = 5, fontface = "bold") +
  annotate("text", x = x_max + offset_x * 1.1, y = y_max + offset_y,
           label = paste0("UP: ", number.genes.upregulated.hfdpp.hfd),
           color = pal["Upregulated"], hjust = 1, size = 5, fontface = "bold") +
  coord_cartesian(
    xlim = c(x_min - offset_x * 1.3, x_max + offset_x * 1.3),
    ylim = c(0, y_max + offset_y * 2),
    clip = "off"
  ) +
  labs(x = "log2FoldChange (HFDpp / HFD)", y = "-log10(padj)") +
  theme_minimal(base_size = 12) +
  theme(
    legend.position      = "none",
    axis.text            = element_text(color = "black"),
    axis.title           = element_text(color = "black"),
    panel.grid.major     = element_blank(),
    panel.grid.minor     = element_blank()
  ) +
  scale_color_manual(values = pal)

ggsave("volcano_plot_hfdpp_hfd_2.svg", width = 8, height = 8, dpi = 300)

```

## Third contrast: HFDpp vs Control

### UP HFDpp vs Control

```{r}
log.fold.change.hfdpp.control <- res.hfdpp.control$log2FoldChange
adjusted.pval.hfdpp.control   <- res.hfdpp.control$padj
names.res.deseq.hfdpp.control <- rownames(res.hfdpp.control)
names(log.fold.change.hfdpp.control) <- names.res.deseq.hfdpp.control
names(adjusted.pval.hfdpp.control)   <- names.res.deseq.hfdpp.control
activated.genes.hfdpp.control <- names.res.deseq.hfdpp.control[
  log.fold.change.hfdpp.control > 2 & adjusted.pval.hfdpp.control < 0.05]
activated.genes.hfdpp.control <- activated.genes.hfdpp.control[!is.na(activated.genes.hfdpp.control)]
number.genes.upregulated.hfdpp.control <- length(activated.genes.hfdpp.control)
number.genes.upregulated.hfdpp.hfd <- length(activated.genes.hfdpp.hfd)
cat(
  "There are", 
  number.genes.upregulated.hfdpp.control, 
  "genes identified as upregulated in HFDpp vs Control\n"
)
```

### DOWN HFDpp vs Control

```{r}
downregulated.genes.hfdpp.control <- names.res.deseq.hfdpp.control[
  log.fold.change.hfdpp.control < -2 & adjusted.pval.hfdpp.control < 0.05]
downregulated.genes.hfdpp.control <- downregulated.genes.hfdpp.control[!is.na(downregulated.genes.hfdpp.control)]
number.genes.downregulated.hfdpp.control <- length(downregulated.genes.hfdpp.control)
cat(
  "There are", 
  number.genes.downregulated.hfdpp.control, 
  "genes identified as downregulated in HFDpp vs Control\n"
)
```

```{r}
df <- data.frame(
  logFC     = log.fold.change.hfdpp.control,
  negLogP   = -log10(adjusted.pval.hfdpp.control),
  status    = "NS",
  row.names = names.res.deseq.hfdpp.control
)
df$status[rownames(df) %in% activated.genes.hfdpp.control]     <- "Upregulated"
df$status[rownames(df) %in% downregulated.genes.hfdpp.control] <- "Downregulated"
df$status <- factor(df$status, levels = c("Downregulated", "NS", "Upregulated"))
df$gene   <- sub(".*\\|", "", rownames(df))
n_genes  <- 10
top_up   <- df %>% filter(status == "Upregulated")   %>% slice_max(negLogP, n = n_genes)
top_down <- df %>% filter(status == "Downregulated") %>% slice_max(negLogP, n = n_genes)
x_min    <- min(df$logFC, na.rm = TRUE)
x_max    <- max(df$logFC, na.rm = TRUE)
x_range  <- x_max - x_min
offset_x <- x_range * 0.15
y_max    <- max(df$negLogP, na.rm = TRUE)
y_min    <- min(df$negLogP, na.rm = TRUE)
y_range  <- y_max - y_min
offset_y <- y_range / (max(nrow(top_up), nrow(top_down)) + 1)
f <- 0.6
label_df_up <- top_up %>%
  arrange(desc(negLogP)) %>%
  mutate(
    label_x = logFC + (x_max - logFC) * f, 
    label_y = y_max - (row_number() - 1) * offset_y,
    group   = "up"
  )
label_df_down <- top_down %>%
  arrange(desc(negLogP)) %>%
  mutate(
    label_x = logFC + (x_min - logFC) * f,  
    label_y = y_max - (row_number() - 1) * offset_y,
    group   = "down"
  )
label_df <- bind_rows(label_df_down, label_df_up)
pal <- c(Downregulated = "#56B4E9", NS = "grey80", Upregulated = "#D55E00")
ggplot(df, aes(logFC, negLogP)) +
  geom_point(aes(color = status), size = 1.5, alpha = 0.8) +
  geom_segment(data = label_df,
               aes(x = logFC, y = negLogP,
                   xend = label_x, yend = label_y),
               color = "grey50") +
  geom_text(data = label_df,
            aes(x = label_x, y = label_y, label = gene,
                color = ifelse(group == "up", "Upregulated", "Downregulated")),
            hjust = ifelse(label_df$group == "up", 0, 1),
            size = 4,
            show.legend = FALSE) +
  geom_vline(xintercept = c(-1, 1),
             linetype = "dashed", color = "grey60") +
  geom_hline(yintercept = -log10(0.05),
             linetype = "dashed", color = "grey60") +
  annotate("text",
           x = x_min - offset_x * 1.1,
           y = y_max + offset_y,
           label = paste0("DOWN: ", number.genes.downregulated.hfdpp.control),
           color = pal["Downregulated"],
           hjust = 0, size = 5, fontface = "bold") +
  annotate("text",
           x = x_max + offset_x * 1.1,
           y = y_max + offset_y,
           label = paste0("UP: ", number.genes.upregulated.hfdpp.control),
           color = pal["Upregulated"],
           hjust = 1, size = 5, fontface = "bold") +
  coord_cartesian(
    xlim = c(x_min - offset_x * 1.3,
             x_max + offset_x * 1.3),
    ylim = c(0, y_max + offset_y * 2),
    clip = "off"
  ) +
  labs(x = "log2FoldChange (HFDpp / Control)",
       y = "-log10(padj)") +
  theme_minimal(base_size = 12) +
  theme(
    legend.position      = "none",
    axis.text            = element_text(color = "black"),
    axis.title           = element_text(color = "black"),
    panel.grid.major     = element_blank(),
    panel.grid.minor     = element_blank()
  ) +
  scale_color_manual(values = pal)

ggsave("volcano_plot_hfdpp_control_2.svg", width = 8, height = 8, dpi = 300)
```

## Heatmap

A heatmap is generated with the top 50 genes by adjuste p-value and Log2FC.

```{r}
# Results from DESeq2
res1 <- data.frame(
  gene     = rownames(res.hfd.control),
  logFC    = res.hfd.control$log2FoldChange,
  padj     = res.hfd.control$padj
)
res2 <- data.frame(
  gene     = rownames(res.hfdpp.hfd),
  logFC    = res.hfdpp.hfd$log2FoldChange,
  padj     = res.hfdpp.hfd$padj
)
res3 <- data.frame(
  gene     = rownames(res.hfdpp.control),
  logFC    = res.hfdpp.control$log2FoldChange,
  padj     = res.hfdpp.control$padj
)
all.res <- bind_rows(res1, res2, res3)

# Adapt names and order by adjusted p value and logFC
gene.score <- all.res %>%
  mutate(
    ID     = sub("\\|.*",   "", gene),
    SYMBOL = sub(".*\\|",   "", gene)
  ) %>%
  group_by(ID, SYMBOL) %>%
  summarise(
    best_padj = min(padj, na.rm=TRUE),
    max_logFC = max(abs(logFC), na.rm=TRUE),
    score     = -log10(best_padj + 1e-300) * max_logFC,
    .groups   = "drop"
  ) %>%
  filter(best_padj < 0.05) %>%
  arrange(desc(score)) %>%
  slice_head(n=50)

top50_ids  <- gene.score$ID
top50_syms <- gene.score$SYMBOL

# Z-score and Top50
z <- t(scale(t(as.matrix(gene.expression.1))))
z.top50 <- z[top50_ids, , drop = FALSE]
rownames(z.top50) <- top50_syms

#### 2) Clustering of genes
row_dist <- dist(z.top50)
row_hc   <- hclust(row_dist, method = "complete")
clusters <- cutree(row_hc, k = 3)

row_annot_df <- data.frame(
  Cluster = factor(clusters)
)
rownames(row_annot_df) <- rownames(z.top50)
cluster_colors <- setNames(
  c("#A1D99B","#9E9AC8","#FC9272"),
  levels(row_annot_df$Cluster)
)
ha_row <- rowAnnotation(
  Cluster = row_annot_df$Cluster,
  col     = list(Cluster = cluster_colors),
  show_annotation_name = FALSE,
  show_legend = FALSE
)

# Conditions
ha_col <- HeatmapAnnotation(
  Condition = design$group,
  col = list(Condition = c(
    Control = "#51A3CC",
    HFD     = "#CC5151",
    HFDpp   = "#A3CC51"
  )),
  annotation_name_side = "left"
)

col_fun <- colorRamp2(
  c(min(z.top50), 0, max(z.top50)),
  c("white", "grey70", "black")
)

ht <- Heatmap(
  z.top50,
  name                = "TPM Z-score",
  col                 = col_fun,
  top_annotation      = ha_col,
  left_annotation = ha_row,
  cluster_rows        = row_hc,
  use_raster = F,
  rect_gp             = gpar(col = "grey40"),
  cluster_columns     = FALSE,
  show_row_names      = TRUE,
  show_column_names   = TRUE,
  row_names_gp        = gpar(fontsize = 8),
  column_names_gp     = gpar(fontsize = 10),
  column_title        = "Heatmap of Top 50 DE Genes",
  column_title_gp     = gpar(fontsize = 14, fontface = "bold"),
  heatmap_legend_param = list(
    title = "TPM Z-score",
    title_gp = gpar(fontsize=10, fontface="bold"),
    labels_gp = gpar(fontsize=8)
  )
)

svg("heatmap_top50.svg", width = 10, height = 8)
draw(
  ht,
  heatmap_legend_side   = "right",
  annotation_legend_side = "right"
)
dev.off()
```

## Venn diagrams

Now, due to the big and complex group of genes altered in the three contrasts, Venn diagrams can be performed to check if the same genes are being up and downregulated in the different tests to study the effect of the pectin.

```{r}
# Define the lists with the contrasts of interest.
up_lists <- list(
  `HFD vs Control`    = activated.genes.hfd.control,
  `HFDpp vs HFD`      = activated.genes.hfdpp.hfd,
  `HFDpp vs Control`  = activated.genes.hfdpp.control
)
down_lists <- list(
  `HFD vs Control`    = downregulated.genes.hfd.control,
  `HFDpp vs HFD`      = downregulated.genes.hfdpp.hfd,
  `HFDpp vs Control`  = downregulated.genes.hfdpp.control
)
cross_up_vs_down <- list(
  `HFDpp vs HFD`    = activated.genes.hfdpp.hfd,
  `HFD vs Control` = downregulated.genes.hfd.control
)
cross_down_vs_up <- list(
  `HFDpp vs HFD`   = downregulated.genes.hfdpp.hfd,
  `HFD vs Control` = activated.genes.hfd.control
)

common_theme <- theme_void(base_size = 14) +
  theme(
    plot.title   = element_text(hjust = 0, face = "bold"),
    plot.margin  = margin(20, 20, 20, 20) 
  )

# Up-regulated across all contrasts
p_up <- ggVennDiagram(up_lists,
                      label       = "count",
                      label_alpha = 0,
                      label_size  = 5,
                      edge_size   = 0.5,
                      lwd         = 0.5,
                      color       = "black") +
  scale_fill_gradient(low = "#f7f7f7", high = "#1a9641") +
  ggtitle("Overlap of Upregulated Genes Across Contrasts") +
  common_theme +
  coord_cartesian(clip = "off")
print(p_up)

ggsave("venn_up_across_contrasts.svg", p_up, width = 10, height = 10, dpi = 300)

# Down-regulated across all contrasts
p_down <- ggVennDiagram(down_lists,
                        label       = "count",
                        label_alpha = 0,
                        label_size  = 5,
                        edge_size   = 0.5,
                        lwd         = 0.5,
                        color       = "black") +
  scale_fill_gradient(low = "#f7f7f7", high = "#d7191c") +
  ggtitle("Overlap of Downregulated Genes Across Contrasts") +
  common_theme +
  coord_cartesian(clip = "off")
print(p_down)

ggsave("venn_down_across_contrasts.svg", p_down, width = 10, height = 10, dpi = 300)

# Up (HFDpp vs HFD) vs Down (HFD vs Control)
p_cross1 <- ggVennDiagram(cross_up_vs_down,
                          label       = "count",
                          label_alpha = 0,
                          label_size  = 5,
                          edge_size   = 0.5,
                          lwd         = 0.5,
                          color       = "black") +
  scale_fill_gradient(low = "#f7f7f7", high = "#7570b3") +
  ggtitle("Overlap: Up (HFDpp vs HFD) & Down (HFD vs Control)") +
  common_theme +
  coord_cartesian(clip = "off")
print(p_cross1)

ggsave("venn_up_vs_down.svg", p_cross1, width = 10, height = 10, dpi = 300)

# Down (HFDpp vs HFD) vs Up (HFD vs Control)
p_cross2 <- ggVennDiagram(cross_down_vs_up,
                          label       = "count",
                          label_alpha = 0,
                          label_size  = 5,
                          edge_size   = 0.5,
                          lwd         = 0.5,
                          color       = "black") +
  scale_fill_gradient(low = "#f7f7f7", high = "#b2912f") +
  ggtitle("Overlap: Down (HFDpp vs HFD) & Up (HFD vs Control)") +
  common_theme +
  coord_cartesian(clip = "off")
print(p_cross2)

ggsave("venn_down_vs_up.svg", p_cross2, width = 10, height = 10, dpi = 300)


```

It is interesting to save different lists with the genes identified in each Venn diagram in order to perform enrichment analysis later.

```{r}
# Genes altered by obesity (HFD vs Control)
upregulated.hfd.control      <- activated.genes.hfd.control
downregulated.hfd.control    <- downregulated.genes.hfd.control
# Genes modulated by pectin in the context of obesity (HFDpp vs HFD)
upregulated.hfdpp.hfd        <- activated.genes.hfdpp.hfd
downregulated.hfdpp.hfd      <- downregulated.genes.hfdpp.hfd
# Genes affected by pectin compared to healthy animals (HFDpp vs Control)
upregulated.hfdpp.control    <- activated.genes.hfdpp.control
downregulated.hfdpp.control  <- downregulated.genes.hfdpp.control
# Genes restored by pectin (reversed pathological expression)
restored.up_by_pectin   <- intersect(downregulated.hfd.control, upregulated.hfdpp.hfd)
restored.down_by_pectin <- intersect(upregulated.hfd.control, downregulated.hfdpp.hfd)
# Genes specifically modulated by pectin (not affected by obesity alone)
all.hfd.control <- union(upregulated.hfd.control, downregulated.hfd.control)
specifically_upregulated_by_pectin   <- setdiff(upregulated.hfdpp.hfd, all.hfd.control)
specifically_downregulated_by_pectin <- setdiff(downregulated.hfdpp.hfd, all.hfd.control)
# Genes not restored by pectin (persistent dysregulation)
not_restored_up   <- setdiff(upregulated.hfd.control, downregulated.hfdpp.hfd)
not_restored_down <- setdiff(downregulated.hfd.control, upregulated.hfdpp.hfd)
# Save all gene lists to individual files
dir.create("gene_lists", showWarnings = FALSE)
writeLines(upregulated.hfd.control,      "gene_lists/upregulated.hfd.control.txt")
writeLines(downregulated.hfd.control,    "gene_lists/downregulated.hfd.control.txt")
writeLines(upregulated.hfdpp.hfd,        "gene_lists/upregulated.hfdpp.hfd.txt")
writeLines(downregulated.hfdpp.hfd,      "gene_lists/downregulated.hfdpp.hfd.txt")
writeLines(upregulated.hfdpp.control,    "gene_lists/upregulated.hfdpp.control.txt")
writeLines(downregulated.hfdpp.control,  "gene_lists/downregulated.hfdpp.control.txt")
writeLines(restored.up_by_pectin,        "gene_lists/restored.up_by_pectin.txt")
writeLines(restored.down_by_pectin,      "gene_lists/restored.down_by_pectin.txt")
writeLines(specifically_upregulated_by_pectin, "gene_lists/specific_up_by_pectin.txt")
writeLines(specifically_downregulated_by_pectin, "gene_lists/specific_down_by_pectin.txt")
writeLines(not_restored_up, "gene_lists/not_restored_up.txt")
writeLines(not_restored_down, "gene_lists/not_restored_down.txt")
```

It is important to translate the gene names to symbol, as they become more intuitive. The output folder must be created before running the function.

```{r}
extract_gene_symbols <- function(input_folder, output_folder) {
  # Check that input folder exists
  if (!dir.exists(input_folder)) {
    stop("Input folder does not exist: ", input_folder)
  }
  # Create output folder
  if (!dir.exists(output_folder)) {
    dir.create(output_folder, recursive = TRUE)
    message("Created output folder: ", output_folder)
  }
  # Get a list of .txt files in the input folder
  files <- list.files(input_folder, pattern = "\\.txt$", full.names = TRUE)
  # Check if any files were found
  if (length(files) == 0) {
    stop("No .txt files found in: ", input_folder)
  }
  # Process each file
  for (input_file in files) {
    lines <- readLines(input_file)
    # Extract gene symbols after |
    symbols <- sapply(strsplit(lines, "\\|"), function(x) {
      if (length(x) >= 2) x[2] else NA
    })
    # Remove NAs
    symbols <- symbols[!is.na(symbols)]
    # Build path
    file_name <- basename(input_file)
    output_file <- file.path(output_folder, file_name)
    # Write symbols to new file
    writeLines(symbols, output_file)
    message("Processed: ", file_name)
  }
  message("All files processed. Output saved to: ", output_folder)
}

extract_gene_symbols("gene_lists", "gene_lists_symbols")
```

# 5. Gene enrichment.

Gene enrichment is performed. A custom function is implemented to perform GO and KEGG enrichments.

```{r}
run_enrichment_all_ontologies <- function(gene_symbols, name_prefix = "contrast") {
  gene_ensembl <- sub("\\|.*", "", gene_symbols)
  entrez <- bitr(gene_ensembl, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
  if (nrow(entrez) == 0) {
    message(paste("No valid ENSEMBL IDs found for", name_prefix))
    return(NULL)
  }
  ont_list <- c("BP", "MF", "CC")
  go_all <- list()
  for (ont in ont_list) {
    go <- enrichGO(gene          = entrez$ENTREZID,
                   OrgDb         = org.Mm.eg.db,
                   ont           = ont,
                   pvalueCutoff  = 0.05,
                   pAdjustMethod = "BH",
                   readable      = TRUE)
    if (nrow(go) > 0) {
      go@ontology <- ont  
      go_all[[ont]] <- go
      write.csv(as.data.frame(go), paste0("GO_", ont, "_", name_prefix, ".csv"), row.names = FALSE)
    }
  }
  kegg <- enrichKEGG(gene          = entrez$ENTREZID,
                     organism      = "mmu",
                     pvalueCutoff  = 0.05)
  if (nrow(kegg) > 0) {
    write.csv(as.data.frame(kegg), paste0("KEGG_", name_prefix, ".csv"), row.names = FALSE)
  }
  return(list(GO = go_all, KEGG = kegg))
}
```

Once the enrichment is ready, we can represent it in a Manhattan-style plot using the next custom function.

```{r}
plot_manhattan_enrichment <- function(go_list, kegg, title = "Enrichment Manhattan Plot", filename = NULL, top_n = 30) {
  # Combine all GO results
  go_combined <- bind_rows(lapply(names(go_list), function(ont) {
    df <- as.data.frame(go_list[[ont]])
    if (nrow(df) == 0) return(NULL)
    df$Ontology <- ont
    return(df)
  }))
  # Add KEGG
  kegg_df <- as.data.frame(kegg)
  if (nrow(kegg_df) > 0) {
    kegg_df$Ontology <- "KEGG"
    go_combined <- bind_rows(go_combined, kegg_df)
  }
  if (nrow(go_combined) == 0) {
    warning("No enriched terms found.")
    return(NULL)
  }
  go_combined <- go_combined %>%
    mutate(logP = -log10(p.adjust)) %>%
    arrange(desc(logP)) %>%
    slice_head(n = top_n) %>%
    mutate(Term = fct_reorder(Description, logP))
  pal <- c("BP" = "#2c7bb6", "MF" = "#fdae61", "CC" = "#abd9e9", "KEGG" = "#d7191c")
  # Plot
  p <- ggplot(go_combined, aes(x = Term, y = logP, fill = Ontology)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = pal) +
    coord_flip() +
    theme_minimal(base_size = 12) +
    labs(title = title, y = "-log10(p.adjust)", x = NULL) +
    theme(legend.position = "top")
  if (!is.null(filename)) {
    ggsave(filename, plot = p, width = 18, height = 8)
  }
  return(p)
}
```

We can use these function to make the enrichments of the genes we have selected before.

```{r}
# CONTRAST 1: HFD vs Control
res1_up   <- run_enrichment_all_ontologies(activated.genes.hfd.control,   "HFD_vs_Control_UP")
res1_down <- run_enrichment_all_ontologies(downregulated.genes.hfd.control, "HFD_vs_Control_DOWN")
plot_manhattan_enrichment(res1_up$GO, res1_up$KEGG, "HFD vs Control - Upregulated",   "manhattan_HFD_vs_Control_UP.svg")
plot_manhattan_enrichment(res1_down$GO, res1_down$KEGG, "HFD vs Control - Downregulated", "manhattan_HFD_vs_Control_DOWN.svg")

# CONTRAST 2: HFDpp vs HFD
res2_up   <- run_enrichment_all_ontologies(activated.genes.hfdpp.hfd,   "HFDpp_vs_HFD_UP")
res2_down <- run_enrichment_all_ontologies(downregulated.genes.hfdpp.hfd, "HFDpp_vs_HFD_DOWN")
plot_manhattan_enrichment(res2_up$GO, res2_up$KEGG, "HFDpp vs HFD - Upregulated",   "manhattan_HFDpp_vs_HFD_UP.svg")
plot_manhattan_enrichment(res2_down$GO, res2_down$KEGG, "HFDpp vs HFD - Downregulated", "manhattan_HFDpp_vs_HFD_DOWN.svg")

# CONTRAST 3: HFDpp vs Control
res3_up   <- run_enrichment_all_ontologies(activated.genes.hfdpp.control,   "HFDpp_vs_Control_UP")
res3_down <- run_enrichment_all_ontologies(downregulated.genes.hfdpp.control, "HFDpp_vs_Control_DOWN")
plot_manhattan_enrichment(res3_up$GO, res3_up$KEGG, "HFDpp vs Control - Upregulated",   "manhattan_HFDpp_vs_Control_UP.svg")
plot_manhattan_enrichment(res3_down$GO, res3_down$KEGG, "HFDpp vs Control - Downregulated", "manhattan_HFDpp_vs_Control_DOWN.svg")

# RESTORED BY PECTIN (reversed genes)
# res4_up <- run_enrichment_all_ontologies(restored.up_by_pectin, "Restored_UP_by_Pectin")  Not enough genes to perform enrichment
res4_down <- run_enrichment_all_ontologies(restored.down_by_pectin, "Restored_DOWN_by_Pectin")
# plot_manhattan_enrichment(res4_up$GO, res4_up$KEGG, "Restored Genes - Up by Pectin", "manhattan_restored_up_by_pectin.svg")
plot_manhattan_enrichment(res4_down$GO, res4_down$KEGG, "Restored Genes - Down by Pectin", "manhattan_restored_down_by_pectin.svg")

# SPECIFICALLY MODULATED BY PECTIN
res5_up <- run_enrichment_all_ontologies(specifically_upregulated_by_pectin, "Specific_UP_by_Pectin")
res5_down <- run_enrichment_all_ontologies(specifically_downregulated_by_pectin, "Specific_DOWN_by_Pectin")
plot_manhattan_enrichment(res5_up$GO, res5_up$KEGG, "Specifically Upregulated by Pectin", "manhattan_specific_up_by_pectin.svg")
plot_manhattan_enrichment(res5_down$GO, res5_down$KEGG, "Specifically Downregulated by Pectin", "manhattan_specific_down_by_pectin.svg")
```

Kegg enrichment is now specifically done.

```{r}
## HFD
res_df <- as.data.frame(res.hfd.control)
res_df$ensembl <- rownames(res_df)
res_df$ensembl <- sub("\\|.*", "", res_df$ensembl)
res_df <- res_df %>% 
  filter(!is.na(padj)) %>%
  filter(abs(log2FoldChange) >= 2, padj < 0.05)  

entrez_map <- bitr(res_df$ensembl, 
                   fromType = "ENSEMBL", 
                   toType = "ENTREZID", 
                   OrgDb = org.Mm.eg.db)

res_mapped <- inner_join(res_df, entrez_map, by = c("ensembl" = "ENSEMBL"))

geneList <- res_mapped$log2FoldChange
names(geneList) <- res_mapped$ENTREZID

ekegg <- enrichKEGG(gene = names(geneList),
                    organism = "mmu",
                    pvalueCutoff = 0.05)

for (pid in ekegg$ID[1:3]) {
  pathview(gene.data = geneList,
           pathway.id = pid,
           species = "mmu",
           out.suffix = "HFD_vs_Control")
} 

## HFDpp
res_df <- as.data.frame(res.hfdpp.hfd)
res_df$ensembl <- rownames(res_df)
res_df$ensembl <- sub("\\|.*", "", res_df$ensembl)
res_df <- res_df %>% 
  filter(!is.na(padj)) %>%
  filter(abs(log2FoldChange) >= 2, padj < 0.05) 
entrez_map <- bitr(res_df$ensembl, 
                   fromType = "ENSEMBL", 
                   toType = "ENTREZID", 
                   OrgDb = org.Mm.eg.db)
res_mapped <- inner_join(res_df, entrez_map, by = c("ensembl" = "ENSEMBL"))
geneList <- res_mapped$log2FoldChange
names(geneList) <- res_mapped$ENTREZID
ekegg <- enrichKEGG(gene = names(geneList),
                    organism = "mmu",
                    pvalueCutoff = 0.05)
for (pid in ekegg$ID[1:3]) {
  pathview(gene.data = geneList,
           pathway.id = pid,
           species = "mmu",
           out.suffix = "HFDpp_vs_HFD")
}
```

# 6. sPLS-DA model

A sPLS-DA model will be implemented to identify the genes that are most important for classifying the samples into their respective groups. Due to the limited number of samples, this model will not be used for predictive purposes.

```{r}
# Prepare data
rownames(gene.expression.1) <- make.unique(rownames(gene.expression.1))
X <- t(gene.expression.1)  # samples x genes
Y <- as.factor(design$group)  # factors: control, hfd, hfdpp
# Perform sPLS-DA model
splsda.res <- splsda(X, Y, ncomp = 2, keepX = c(50, 50))
# Take selected genes in each component.
selected_genes_comp1 <- selectVar(splsda.res, comp = 1)$name
selected_genes_comp2 <- selectVar(splsda.res, comp = 2)$name
top_genes <- unique(c(selected_genes_comp1, selected_genes_comp2))
# Translate Ensembl -> Symbol
mapped <- bitr(top_genes,
               fromType = "ENSEMBL",
               toType = "SYMBOL",
               OrgDb = org.Mm.eg.db)
# Build name vector for each variable
all_genes <- rownames(splsda.res$loadings$X)  
named_labels <- mapped$SYMBOL[match(all_genes, mapped$ENSEMBL)]
named_labels[is.na(named_labels)] <- all_genes[is.na(named_labels)]

# Visualization
## Samples (individuals)
plotIndiv(splsda.res, comp = c(1, 2), group = Y, legend = TRUE,
          title = "sPLS-DA of DE genes (2 components)")
## Loadings in component 1 and 2
plotLoadings(splsda.res, comp = 1, method = 'mean', contrib = 'max',
             name.var = named_labels,
             title = "Top contributing genes - Comp 1")
plotLoadings(splsda.res, comp = 2, method = 'mean', contrib = 'max',
             name.var = named_labels,
             title = "Top contributing genes - Comp 2")
# Save images
svg("splsda_loadings_comp1.svg", width = 15, height = 10)
plotLoadings(splsda.res, comp = 1, method = 'mean', contrib = 'max',
             name.var = named_labels,
             title = "Top contributing genes - Comp 1")
dev.off()
# Componente 2
svg("splsda_loadings_comp2.svg", width = 15, height = 10)
plotLoadings(splsda.res, comp = 2, method = 'mean', contrib = 'max',
             name.var = named_labels,
             title = "Top contributing genes - Comp 2")
dev.off()

# We can save a table with the genes selected.
# Convert loadings matrix to data.frame
loadings_df <- as.data.frame(splsda.res$loadings$X) %>%
  rownames_to_column(var = "ENSEMBL")
# Change to long format
loadings_long <- loadings_df %>%
  tidyr::pivot_longer(
    cols = starts_with("comp"),
    names_to = "Component",
    values_to = "Loading"
  ) %>%
  filter(Loading != 0) %>%  # Keep only selected genes
  mutate(Direction = ifelse(Loading > 0, "UP", "DOWN"))
# Join with gene symbols
loadings_annotated <- loadings_long %>%
  left_join(mapped, by = "ENSEMBL") %>%
  arrange(Component, desc(abs(Loading)))
write.csv(loadings_annotated, "splsda_selected_genes_by_component.csv", row.names = FALSE)
```
